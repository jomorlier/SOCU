
#'initialization function
#'Author: Samineh Bagheri
#'This script is not in its final format and will be changed very often
#'
#'
#'
#'



#--------Helper Functions-------------#

generateInitPop<-function(size,dimension,dLower=-1,dUpper=1,method="LHS",seed=seed){
  #dLower: desired Lower
  #dupper: desired Upper
  set.seed(seed)
  switch(method,
         "LHS"={initPop<-randomLHS(size,dimension);
         initPop<-rescale(initPop,to=c(dLower,dUpper),from=c(0,1))},
         "Random"={t<-c(1:size);initPop<-sapply(t,FUN=function(t){
           runif(dimension,min=dLower,max=dUpper)
         });
         initPop<-t(initPop)}
         )
  
  mynames<-paste("x",c(1:dimension),sep="")
  colnames(initPop)<-mynames
  return(initPop)
}

rescaleWrapper<-function(fn,lower,upper,dimension,newlower,newupper){
  oldfn<-fn                     
  newfn<-function(x){
    x<-sapply(1:length(x) , function(i){scales::rescale(x[i],to=c(lower[i],upper[i]),from=c(newlower,newupper))
    })
    y<-oldfn(x)
    return(y)
  }
  return(newfn)
}

#' @param fn              objective and constrain function to be optimized: \code{fn} must be defined as a function which recieves 
#'                        a vector \code{x} of size of the dimension d and resturns a numeric vector of \code{eval} containing value of the 
#'                        objective and constraint function at the point \code{x}
#' @param budget          The maximum permitted function evaluation            
#' @param name            a character-class variable, This character is used the prefix of the generated plots if the \code{vis} is set to TRUE
#' @param dimension       dimension of the problem to be optimized
#' @param lower           lower bound \eqn{\vec{a}} of search space, same \code{dimension} as the problem
#' @param upper           upper bound \eqn{\vec{a}} of search space, same \code{dimension} as the problem
#' @param dUpper          [-1] lower bound of each rescaled input space dimension
#' @param dLower          [1]  upper bound of each rescaled input space dimension  
#' @param nConstraints    number of constraint functions
#' @param tol             [1e-10] constraint violation tolerance, when violation < tol the solution is considered as feasible
#' @param initSize        [3*\code{dimension}] The number initial population generated by \code{initMethod} method
#' @param initMethod      ["LHS"] random initial population method can be set to "LHS" or "Random" using \link{\code{runif}} random uniform distribution 
#'                        or \link{\code{randomLHS}} Latin hypercube sampling, respectively.
#' @param optimizer       ["GenSA"] The internal optimizer which minimizes the \code{EImod} function. 
#'                        It can be set to "GenSA" for general simulated anealing or "COBYLA" from \code{nloptr} package.
#'                        using "COBYLA" is not recommended, because often \code{\link{EImod}} is a very spiky function 
#'                        and alocal optimizer like \code{cobyla} often fails to find the correct optimum   
#' @param smoothSA        [FALSE] only relevant when \code{optimizer} is set to "GenSA", control parameter for GenSA (see \code{\link{GenSA}})
#'                        It is recommended to be set to FALSE because \code{EImod} function often is a non-smooth function                
#' @param maxTime         [30] only relevant when \code{optimizer} is set to "GenSA", time in seconds for GenSA                
#' @param kType           kriging family type which can be set to "UK" (universal Krigin) or "SK" simple Kriging (see \code{\link{predict.km}})                         
#' @param doNUGGET        [FALSE] Set to TRUE to enable nuggest effect for modeling the objective function (see \code{\link{robustModeling}}, \code{\link{km}})
#'                        It must be set to FALSE when the \code{noiseVar} is enabled
#' @param doConNUGGET     [FALSE] Set to TRUE to enable nuggest effect for modeling the constraint functions (see \code{\link{robustModeling}}, \code{\link{km}})
#'                        It must be set to FALSE when the \code{conNoiseVar} is enabled
#' @param noiseVar        [0.05]  a constant numeric value for the noise value at each evaluated point for training the objective model
#'                        (see \code{\link{robustModeling}}) when it is set to NULL the sd value at evaluated points becomes zero 
#'                        when it is not set to NULL then the doNUGGET must be set to FALSE
#' @param conNoiseVar     [NULL]  a constant numeric value for the noise value at each evaluated point for training the constraint model
#'                        (see \code{\link{robustModeling}}) when it is set to NULL the sd value at evaluated points becomes zero 
#'                        when it is not set to NULL then the doNUGGET must be set to FALSE  
#'-------# Add-ons #-----------------------------------------------------------------------
#' @param doTRIKE        [FALSE] if set to TRUE:  it performs a trust region algorithm implemented according to Regis' Work (see \code{\link{doTRIKE.R}})
#' @param doREPLACE      [FALSE] if set to TRUE:  it removes the old infill points if they are located very close to each other (less than 1e-5 Euclidean distance)
#' @param defEPS         list of control parameters for epsilon mechanism, the default values are set by \code{defaultEPS()}
#' @param defGamma       list of control parameters for Gamma mechanism, the default values are set by \code{defaultEPS()}
#' @param defMiniTR      list of control parameters for a local search in a defined trust region after each optimization iteration, 
#'                       the default values are set by \code{defaultMiniTR()}
#' @param NUmech         [FALSE] if set to TRUE:  nu-mechanism is performed to repait the infeasible solutions                                            
#' @param repairInfeas   [TRUE]  if set to TRUE: RI2 repair algorithm is performed to repair the slightly violated ifill points
#' @param ri             list of control parameters for RI2 repair algorithm, the default values are set by \code{defaultRI()}
#' @param handleCrash    [TRUE] Set to TRUE: avoids software crashs in case of ill-conditioned models. (see \code{robustModeling.R})
#'
#'-------# Add-ons finished#-----------------------------------------------------------------------
#' @param fCalc          ["beta"] a character string, assigning the algorithm used for calculting the feasibility function (see \code{feasibilityMeasure.R},\code{calculateF()}) 
#'                       It can be set to "alpha" (old algorithm from Schonlau) or "beta" or "mixed" which is the mixed version of "alpha" and "beta"
#' @param wtType         ["iLin"] Only is relevant if the \code{fCalc}="mixed". "iLin": linearly increasing, "dLin": linearly decreasing, 
#'                       "adaptive": adapting the coefficient iteratively based on the feasibility rate
#'                       It sets the changing scheme of the "alpha" and "beta" coefficient  (see \code{feasibilityMeasure.R},\code{calculateF()})
#' @param vis            [FALSE] set to TRUE, it visualises the problem in each iterations and saves the plot. The visualisation includes:
#'                       (1). Expected improvement of Ojective function    
#'                       (2). Caclulated Feasibility function                                
#'                       (3). Caclulated Feasibility function                                
#'                       (4). Modified Expected Improvment EImod=EI*F  
#' @param visZoom        [FALSE] if set to TRUE: in each iteration the visualisation zooms in more to the real optimum
#'                       It is only relevant if the \code{solu} is set to the through solution for dignostic purposes
#'                                               
#' @param seed           [42] seed for random number generator 
#[deprecated] @param probP          SB: I don't know anymore what was the probP for, do we still need it or shall I remove it
#' @param solu           The real optimum only if it is provided for dignostic issues
#' @param nu             [1] exponent for EI in EImod, EImod=EI^nu * F^NU
#' @param TRUEPLUGIN     [TRUE] if set to TRUE: the plugin value passed \code{\link{myEI()}} is not the the objective value of the best feasible solution
#'                       but either a fixed value or a modifed plugin=plugin+|plugin|/2. (see \code{PLUGINTYPE})
#' @param PLUGINTYPE     ["fixed"]. a character string, only relevant when \code{TRUEPLUGIN=FALSE}. It can be set to "fixed" then plugin=Constant or
#'                       "adaptive":  plugin=plugin+|plugin|/2, (see mainSORC.R )
#' @param useEI          [TRUE] when set to FALSE then the modified Expected improvement EImod is caluclated with real objective model and not the expected improvement of objective
#'                       TRUE : EImod=EI^nu * F^NU, FALSE: obj^nu * F^NU
#'                                                      
#' @param verbose       [0] This parameter controls the tracing level. 0: prints the optimization progress in every 10 iterations
#'                       1: optimization progress and computation time after 10 iterations
#'                       2: optimization progress and computation time after each iteration  
#'                       3: optimization progress and computation time after each iteration, debugging messages                                                   

                                                      
                                        

initializeSORC<-function(fn
                         ,budget=NA,name=NA
                         ,dLower=-1,dUpper=1,lower,upper,dimension
                         ,nConstraints
                         ,tol=1e-10
                         ,initSize,initMethod="LHS"
                         ,optimizer="GenSA",smoothSA=F,maxTime=30
                         ,useSBRBF=defaultSBRBF()
                         ,kType="UK",doNUGGET=F,doConNUGGET=T
                         ,noiseVar=NULL, conNoiseVar=NULL
                         ,doTRIKE=F,doREPLACE=F
                         ,defEPS=defaultEPS()
                         ,defGamma=defaultGamma()
                         ,defMiniTR=defaultMiniTR()
                         ,NUmech=F
                         ,repairInfeas=FALSE
                         ,ri=defaultRI()  #add-ons
                         ,handleCrash=T
                         ,fCalc="alpha", wtType="iLin"
                         ,closeSOLU=F #deprecated, will be omitted
                         ,vis=F,visZoom=F
                         ,seed=42
                         ,probP=NULL
                         ,solu=NULL
                         ,nu=1        
                         ,PLUGINTYPE="adaptive"
                         ,constantSigma=NULL
                         ,useEI=T
                         ,bcfac=1
                         ,verbose=0
                        # ,activeCr=5 #SB: what is this? can be omitted? deprectaed
                         ){
  if(is.na(budget)){
    budget<-15*dimension
  }
  if (!is.null(noiseVar))
    if (doNUGGET) stop("A non-NULL noiseVar requires doNUGGET==F !")
  if (!is.null(conNoiseVar))
    if (doConNUGGET) stop("A non-NULL conNoiseVar requires doConNUGGET==F !")
  if (defMiniTR$active==T)
    if (doTRIKE==T) stop("Cannot have both defMiniTR$active and doTRIKE==T")
#  if(vis==T && dimension >2) vis<-F
  ###generate the initial population
  initPop<-generateInitPop(size=initSize,dimension=dimension,dLower=dLower,dUpper=dUpper,method=initMethod,seed = seed)
  #The generated initPop is suppesed to be scaled in [-1,1]^dimension
  #Therefore we need to modify the function in case they have some other box constraints
  originalFn<-fn
  fn<-rescaleWrapper(fn=fn,lower=lower,upper=upper,dimension=dimension,newlower=dLower,newupper=dUpper)
  
  #######################################
  # Evaluate the initial Population     #
  #######################################
  res<-apply(initPop,1,fn)
  Fres<-res[1,]
  Gres<-res[-1,]
  Gres<-as.matrix(Gres)
  if(nConstraints>1)Gres<-t(Gres)
  
  #browser()
  optim<-NA
  if(is.null(solu)!=T){
    optim<-originalFn(solu)[1]
    for(i in c(1:dimension)){
      solu[i]<-rescale(solu[i],from=c(lower[i],upper[i]),to=c(dLower,dUpper))
    }
  }

if(verbose<2)
  printIter<-10
else
  printIter<-1
 SORC<-list(fn=fn,
            originalFn=originalFn,
            dimension=dimension,
            nConstraints=nConstraints,
            upper=upper,
            lower=lower,
            dUpper=dUpper,
            dLower=dLower,
            tol=tol,
            kType=kType,
            wt=0,
            initSize=initSize,
            initMethod=initMethod,
            budget=budget,
            iter=initSize,
            optimizer=optimizer,
            Fres=Fres,
            Gres=Gres,
            pop=data.frame(initPop),
            vis=vis,
            visZoom=visZoom,
            probP=probP,
            solu=solu,
            optim=optim,
            name=name,
            lcurrent=2*(dUpper-dLower),
            doTRIKE=doTRIKE,
            doNUGGET=doNUGGET,
            doConNUGGET=doConNUGGET,
            doREPLACE=doREPLACE,
            noiseVar=noiseVar,
            conNoiseVar=conNoiseVar,
            handleCrash =handleCrash,
            wtType=wtType,
            #closeSOLU=closeSOLU,
            fCalc=fCalc,
            nu=nu,
            NU=rep(1,nConstraints),
            smoothSA=smoothSA,
            maxTime=maxTime,
            #activeCr=activeCr, #deprectaed
            feasCount=rep(0,nConstraints),
            infeasCount=rep(0,nConstraints),
            feasCountG=rep(0,nConstraints),
            infeasCountG=rep(0,nConstraints),
            defEPS=defEPS,
            defGamma=defGamma,
            NUmech=NUmech,
            defMiniTR=defMiniTR,
            ri=ri,
            repairInfeas=repairInfeas,
            gamma=defGamma$gammaInit,
            PLUGINTYPE=PLUGINTYPE,
            useEI=useEI,
            constantSigma=constantSigma,
            bcfac=bcfac,
            useSBRBF=useSBRBF,
            verbose=verbose,
            printIter=printIter,
            SORCseed=seed
            )
 SORC$defEPS<-setOpts(defEPS,defaultEPS())
 SORC$defGamma<-setOpts(defGamma,defaultGamma())
 SORC$defMiniTR<-setOpts(defMiniTR,defaultMiniTR())
 SORC$ri <- setOpts(SORC$ri,defaultRI())
 SORC$useSBRBF <- setOpts(SORC$useSBRBF,defaultSBRBF())
 
 
 
 return(SORC) 
}